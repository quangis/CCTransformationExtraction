# Generated from GeoAnQu.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3U")
        buf.write("\u02ae\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\3\2\3\2\3\2\3\2\5\2U\n\2\3\2\3\2\3\2\5")
        buf.write("\2Z\n\2\3\2\5\2]\n\2\5\2_\n\2\3\2\3\2\5\2c\n\2\3\2\5\2")
        buf.write("f\n\2\3\2\5\2i\n\2\5\2k\n\2\3\2\3\2\3\2\5\2p\n\2\7\2r")
        buf.write("\n\2\f\2\16\2u\13\2\3\2\5\2x\n\2\3\2\3\2\3\2\5\2}\n\2")
        buf.write("\5\2\177\n\2\3\2\5\2\u0082\n\2\3\2\5\2\u0085\n\2\3\2\3")
        buf.write("\2\5\2\u0089\n\2\3\2\5\2\u008c\n\2\3\2\5\2\u008f\n\2\3")
        buf.write("\2\3\2\5\2\u0093\n\2\6\2\u0095\n\2\r\2\16\2\u0096\7\2")
        buf.write("\u0099\n\2\f\2\16\2\u009c\13\2\3\2\5\2\u009f\n\2\3\2\3")
        buf.write("\2\5\2\u00a3\n\2\3\2\5\2\u00a6\n\2\5\2\u00a8\n\2\3\3\3")
        buf.write("\3\3\4\3\4\3\4\3\4\3\4\5\4\u00b1\n\4\3\4\5\4\u00b4\n\4")
        buf.write("\3\4\3\4\5\4\u00b8\n\4\6\4\u00ba\n\4\r\4\16\4\u00bb\3")
        buf.write("\4\3\4\5\4\u00c0\n\4\3\4\5\4\u00c3\n\4\3\4\3\4\5\4\u00c7")
        buf.write("\n\4\3\4\3\4\5\4\u00cb\n\4\7\4\u00cd\n\4\f\4\16\4\u00d0")
        buf.write("\13\4\3\4\5\4\u00d3\n\4\3\4\5\4\u00d6\n\4\3\4\3\4\3\4")
        buf.write("\5\4\u00db\n\4\3\4\5\4\u00de\n\4\3\4\7\4\u00e1\n\4\f\4")
        buf.write("\16\4\u00e4\13\4\3\4\5\4\u00e7\n\4\3\4\5\4\u00ea\n\4\3")
        buf.write("\4\7\4\u00ed\n\4\f\4\16\4\u00f0\13\4\3\4\5\4\u00f3\n\4")
        buf.write("\3\4\7\4\u00f6\n\4\f\4\16\4\u00f9\13\4\3\4\3\4\3\4\3\4")
        buf.write("\5\4\u00ff\n\4\3\5\3\5\3\5\3\6\3\6\5\6\u0106\n\6\3\6\5")
        buf.write("\6\u0109\n\6\3\6\3\6\5\6\u010d\n\6\3\6\3\6\5\6\u0111\n")
        buf.write("\6\6\6\u0113\n\6\r\6\16\6\u0114\3\6\3\6\5\6\u0119\n\6")
        buf.write("\5\6\u011b\n\6\3\6\5\6\u011e\n\6\3\7\3\7\3\b\3\b\5\b\u0124")
        buf.write("\n\b\3\b\3\b\3\b\5\b\u0129\n\b\3\b\3\b\5\b\u012d\n\b\3")
        buf.write("\b\5\b\u0130\n\b\3\t\3\t\3\t\5\t\u0135\n\t\3\t\3\t\3\n")
        buf.write("\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u0145")
        buf.write("\n\n\5\n\u0147\n\n\3\n\5\n\u014a\n\n\3\n\5\n\u014d\n\n")
        buf.write("\3\n\3\n\5\n\u0151\n\n\3\n\5\n\u0154\n\n\3\n\3\n\5\n\u0158")
        buf.write("\n\n\3\n\5\n\u015b\n\n\3\n\3\n\3\n\3\n\6\n\u0161\n\n\r")
        buf.write("\n\16\n\u0162\3\n\5\n\u0166\n\n\3\n\5\n\u0169\n\n\3\n")
        buf.write("\3\n\5\n\u016d\n\n\3\n\3\n\3\n\5\n\u0172\n\n\3\n\5\n\u0175")
        buf.write("\n\n\3\n\3\n\3\n\3\n\5\n\u017b\n\n\3\n\5\n\u017e\n\n\3")
        buf.write("\n\3\n\5\n\u0182\n\n\3\n\5\n\u0185\n\n\3\n\3\n\3\n\5\n")
        buf.write("\u018a\n\n\5\n\u018c\n\n\3\n\3\n\3\n\5\n\u0191\n\n\3\13")
        buf.write("\5\13\u0194\n\13\3\13\3\13\3\13\5\13\u0199\n\13\3\13\5")
        buf.write("\13\u019c\n\13\3\f\3\f\3\f\5\f\u01a1\n\f\3\f\3\f\5\f\u01a5")
        buf.write("\n\f\3\r\3\r\5\r\u01a9\n\r\3\r\5\r\u01ac\n\r\6\r\u01ae")
        buf.write("\n\r\r\r\16\r\u01af\3\r\3\r\5\r\u01b4\n\r\3\r\5\r\u01b7")
        buf.write("\n\r\3\r\3\r\5\r\u01bb\n\r\3\r\3\r\3\r\3\r\5\r\u01c1\n")
        buf.write("\r\3\r\3\r\5\r\u01c5\n\r\5\r\u01c7\n\r\3\r\5\r\u01ca\n")
        buf.write("\r\6\r\u01cc\n\r\r\r\16\r\u01cd\3\16\3\16\5\16\u01d2\n")
        buf.write("\16\3\16\5\16\u01d5\n\16\6\16\u01d7\n\16\r\16\16\16\u01d8")
        buf.write("\3\16\5\16\u01dc\n\16\3\16\3\16\3\16\5\16\u01e1\n\16\3")
        buf.write("\16\3\16\5\16\u01e5\n\16\3\17\5\17\u01e8\n\17\3\17\3\17")
        buf.write("\5\17\u01ec\n\17\3\17\5\17\u01ef\n\17\3\17\5\17\u01f2")
        buf.write("\n\17\3\17\3\17\3\17\6\17\u01f7\n\17\r\17\16\17\u01f8")
        buf.write("\3\20\5\20\u01fc\n\20\3\20\3\20\5\20\u0200\n\20\3\20\3")
        buf.write("\20\5\20\u0204\n\20\3\20\5\20\u0207\n\20\6\20\u0209\n")
        buf.write("\20\r\20\16\20\u020a\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u021c\n")
        buf.write("\21\5\21\u021e\n\21\3\22\3\22\3\23\3\23\3\24\3\24\3\24")
        buf.write("\3\24\5\24\u0228\n\24\3\24\5\24\u022b\n\24\3\25\3\25\3")
        buf.write("\26\3\26\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32")
        buf.write("\3\32\5\32\u023b\n\32\3\33\3\33\3\33\3\34\3\34\3\34\3")
        buf.write("\35\3\35\3\35\3\36\3\36\3\36\3\37\3\37\3 \3 \3 \3 \3 ")
        buf.write("\3 \3 \3 \3 \5 \u0254\n \3!\3!\3!\3\"\3\"\3\"\3\"\3#\3")
        buf.write("#\3#\3#\5#\u0261\n#\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\3%\3%\3%\5%\u029b\n%\3&\3&\3&\3&\5&\u02a1")
        buf.write("\n&\3&\5&\u02a4\n&\3\'\3\'\3\'\5\'\u02a9\n\'\3(\3(\3(")
        buf.write("\3(\2\2)\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(")
        buf.write("*,.\60\62\64\668:<>@BDFHJLN\2\20\3\2\6\7\3\2\b\t\4\2\b")
        buf.write("\b\n\13\3\2\f\17\4\2\f\f\22\22\4\2\13\13\r\16\3\2\26\27")
        buf.write("\3\2\r\16\4\2\5\5\r\r\3\2\30\36\3\2 #\3\2\13\r\4\2\4\4")
        buf.write("$$\3\2)*\2\u0332\2j\3\2\2\2\4\u00a9\3\2\2\2\6\u00fe\3")
        buf.write("\2\2\2\b\u0100\3\2\2\2\n\u011d\3\2\2\2\f\u011f\3\2\2\2")
        buf.write("\16\u012f\3\2\2\2\20\u0131\3\2\2\2\22\u0190\3\2\2\2\24")
        buf.write("\u0193\3\2\2\2\26\u01a0\3\2\2\2\30\u01b3\3\2\2\2\32\u01d6")
        buf.write("\3\2\2\2\34\u01e7\3\2\2\2\36\u01fb\3\2\2\2 \u021d\3\2")
        buf.write("\2\2\"\u021f\3\2\2\2$\u0221\3\2\2\2&\u0223\3\2\2\2(\u022c")
        buf.write("\3\2\2\2*\u022e\3\2\2\2,\u0230\3\2\2\2.\u0232\3\2\2\2")
        buf.write("\60\u0234\3\2\2\2\62\u023a\3\2\2\2\64\u023c\3\2\2\2\66")
        buf.write("\u023f\3\2\2\28\u0242\3\2\2\2:\u0245\3\2\2\2<\u0248\3")
        buf.write("\2\2\2>\u0253\3\2\2\2@\u0255\3\2\2\2B\u0258\3\2\2\2D\u0260")
        buf.write("\3\2\2\2F\u0262\3\2\2\2H\u029a\3\2\2\2J\u02a3\3\2\2\2")
        buf.write("L\u02a8\3\2\2\2N\u02aa\3\2\2\2P^\7E\2\2QT\7I\2\2RU\5*")
        buf.write("\26\2SU\5.\30\2TR\3\2\2\2TS\3\2\2\2TU\3\2\2\2UV\3\2\2")
        buf.write("\2V_\5\6\4\2WY\5\6\4\2XZ\7I\2\2YX\3\2\2\2YZ\3\2\2\2Z\\")
        buf.write("\3\2\2\2[]\5\4\3\2\\[\3\2\2\2\\]\3\2\2\2]_\3\2\2\2^Q\3")
        buf.write("\2\2\2^W\3\2\2\2_k\3\2\2\2`b\5\6\4\2ac\7\3\2\2ba\3\2\2")
        buf.write("\2bc\3\2\2\2ce\3\2\2\2df\7I\2\2ed\3\2\2\2ef\3\2\2\2fh")
        buf.write("\3\2\2\2gi\5\4\3\2hg\3\2\2\2hi\3\2\2\2ik\3\2\2\2jP\3\2")
        buf.write("\2\2j`\3\2\2\2ks\3\2\2\2lo\5\22\n\2mp\7\4\2\2np\5\4\3")
        buf.write("\2om\3\2\2\2on\3\2\2\2op\3\2\2\2pr\3\2\2\2ql\3\2\2\2r")
        buf.write("u\3\2\2\2sq\3\2\2\2st\3\2\2\2tw\3\2\2\2us\3\2\2\2vx\5")
        buf.write("\b\5\2wv\3\2\2\2wx\3\2\2\2x\u0084\3\2\2\2y\177\7\5\2\2")
        buf.write("z|\7\3\2\2{}\7I\2\2|{\3\2\2\2|}\3\2\2\2}\177\3\2\2\2~")
        buf.write("y\3\2\2\2~z\3\2\2\2~\177\3\2\2\2\177\u0081\3\2\2\2\u0080")
        buf.write("\u0082\5\4\3\2\u0081\u0080\3\2\2\2\u0081\u0082\3\2\2\2")
        buf.write("\u0082\u0083\3\2\2\2\u0083\u0085\5 \21\2\u0084~\3\2\2")
        buf.write("\2\u0084\u0085\3\2\2\2\u0085\u0088\3\2\2\2\u0086\u0087")
        buf.write("\t\2\2\2\u0087\u0089\5J&\2\u0088\u0086\3\2\2\2\u0088\u0089")
        buf.write("\3\2\2\2\u0089\u008b\3\2\2\2\u008a\u008c\5\22\n\2\u008b")
        buf.write("\u008a\3\2\2\2\u008b\u008c\3\2\2\2\u008c\u009a\3\2\2\2")
        buf.write("\u008d\u008f\t\3\2\2\u008e\u008d\3\2\2\2\u008e\u008f\3")
        buf.write("\2\2\2\u008f\u0094\3\2\2\2\u0090\u0092\5L\'\2\u0091\u0093")
        buf.write("\7\4\2\2\u0092\u0091\3\2\2\2\u0092\u0093\3\2\2\2\u0093")
        buf.write("\u0095\3\2\2\2\u0094\u0090\3\2\2\2\u0095\u0096\3\2\2\2")
        buf.write("\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u0099\3")
        buf.write("\2\2\2\u0098\u008e\3\2\2\2\u0099\u009c\3\2\2\2\u009a\u0098")
        buf.write("\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u00a7\3\2\2\2\u009c")
        buf.write("\u009a\3\2\2\2\u009d\u009f\t\4\2\2\u009e\u009d\3\2\2\2")
        buf.write("\u009e\u009f\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a2\5")
        buf.write("N(\2\u00a1\u00a3\7\f\2\2\u00a2\u00a1\3\2\2\2\u00a2\u00a3")
        buf.write("\3\2\2\2\u00a3\u00a5\3\2\2\2\u00a4\u00a6\5N(\2\u00a5\u00a4")
        buf.write("\3\2\2\2\u00a5\u00a6\3\2\2\2\u00a6\u00a8\3\2\2\2\u00a7")
        buf.write("\u009e\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\3\3\2\2\2\u00a9")
        buf.write("\u00aa\7J\2\2\u00aa\5\3\2\2\2\u00ab\u00ff\5\n\6\2\u00ac")
        buf.write("\u00ad\5\f\7\2\u00ad\u00ae\5H%\2\u00ae\u00ff\3\2\2\2\u00af")
        buf.write("\u00b1\5\"\22\2\u00b0\u00af\3\2\2\2\u00b0\u00b1\3\2\2")
        buf.write("\2\u00b1\u00b3\3\2\2\2\u00b2\u00b4\7S\2\2\u00b3\u00b2")
        buf.write("\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\u00b9\3\2\2\2\u00b5")
        buf.write("\u00b7\5H%\2\u00b6\u00b8\7\4\2\2\u00b7\u00b6\3\2\2\2\u00b7")
        buf.write("\u00b8\3\2\2\2\u00b8\u00ba\3\2\2\2\u00b9\u00b5\3\2\2\2")
        buf.write("\u00ba\u00bb\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bb\u00bc\3")
        buf.write("\2\2\2\u00bc\u00ce\3\2\2\2\u00bd\u00bf\t\5\2\2\u00be\u00c0")
        buf.write("\7S\2\2\u00bf\u00be\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0")
        buf.write("\u00c2\3\2\2\2\u00c1\u00c3\7\20\2\2\u00c2\u00c1\3\2\2")
        buf.write("\2\u00c2\u00c3\3\2\2\2\u00c3\u00c6\3\2\2\2\u00c4\u00c7")
        buf.write("\7\21\2\2\u00c5\u00c7\5.\30\2\u00c6\u00c4\3\2\2\2\u00c6")
        buf.write("\u00c5\3\2\2\2\u00c6\u00c7\3\2\2\2\u00c7\u00ca\3\2\2\2")
        buf.write("\u00c8\u00cb\5H%\2\u00c9\u00cb\5<\37\2\u00ca\u00c8\3\2")
        buf.write("\2\2\u00ca\u00c9\3\2\2\2\u00cb\u00cd\3\2\2\2\u00cc\u00bd")
        buf.write("\3\2\2\2\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3\2\2\2\u00ce")
        buf.write("\u00cf\3\2\2\2\u00cf\u00d2\3\2\2\2\u00d0\u00ce\3\2\2\2")
        buf.write("\u00d1\u00d3\5\16\b\2\u00d2\u00d1\3\2\2\2\u00d2\u00d3")
        buf.write("\3\2\2\2\u00d3\u00ff\3\2\2\2\u00d4\u00d6\5\"\22\2\u00d5")
        buf.write("\u00d4\3\2\2\2\u00d5\u00d6\3\2\2\2\u00d6\u00da\3\2\2\2")
        buf.write("\u00d7\u00db\5@!\2\u00d8\u00db\5B\"\2\u00d9\u00db\5H%")
        buf.write("\2\u00da\u00d7\3\2\2\2\u00da\u00d8\3\2\2\2\u00da\u00d9")
        buf.write("\3\2\2\2\u00db\u00e2\3\2\2\2\u00dc\u00de\t\6\2\2\u00dd")
        buf.write("\u00dc\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u00df\3\2\2\2")
        buf.write("\u00df\u00e1\5\36\20\2\u00e0\u00dd\3\2\2\2\u00e1\u00e4")
        buf.write("\3\2\2\2\u00e2\u00e0\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3")
        buf.write("\u00ee\3\2\2\2\u00e4\u00e2\3\2\2\2\u00e5\u00e7\t\7\2\2")
        buf.write("\u00e6\u00e5\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7\u00e9\3")
        buf.write("\2\2\2\u00e8\u00ea\7\20\2\2\u00e9\u00e8\3\2\2\2\u00e9")
        buf.write("\u00ea\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ed\5\34\17")
        buf.write("\2\u00ec\u00e6\3\2\2\2\u00ed\u00f0\3\2\2\2\u00ee\u00ec")
        buf.write("\3\2\2\2\u00ee\u00ef\3\2\2\2\u00ef\u00f7\3\2\2\2\u00f0")
        buf.write("\u00ee\3\2\2\2\u00f1\u00f3\7\f\2\2\u00f2\u00f1\3\2\2\2")
        buf.write("\u00f2\u00f3\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4\u00f6\5")
        buf.write("\36\20\2\u00f5\u00f2\3\2\2\2\u00f6\u00f9\3\2\2\2\u00f7")
        buf.write("\u00f5\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u00ff\3\2\2\2")
        buf.write("\u00f9\u00f7\3\2\2\2\u00fa\u00fb\5H%\2\u00fb\u00fc\7\23")
        buf.write("\2\2\u00fc\u00fd\5@!\2\u00fd\u00ff\3\2\2\2\u00fe\u00ab")
        buf.write("\3\2\2\2\u00fe\u00ac\3\2\2\2\u00fe\u00b0\3\2\2\2\u00fe")
        buf.write("\u00d5\3\2\2\2\u00fe\u00fa\3\2\2\2\u00ff\7\3\2\2\2\u0100")
        buf.write("\u0101\7\f\2\2\u0101\u0102\5H%\2\u0102\t\3\2\2\2\u0103")
        buf.write("\u0105\7F\2\2\u0104\u0106\7I\2\2\u0105\u0104\3\2\2\2\u0105")
        buf.write("\u0106\3\2\2\2\u0106\u0108\3\2\2\2\u0107\u0109\5\4\3\2")
        buf.write("\u0108\u0107\3\2\2\2\u0108\u0109\3\2\2\2\u0109\u011a\3")
        buf.write("\2\2\2\u010a\u011b\5\20\t\2\u010b\u010d\5*\26\2\u010c")
        buf.write("\u010b\3\2\2\2\u010c\u010d\3\2\2\2\u010d\u0112\3\2\2\2")
        buf.write("\u010e\u0110\5H%\2\u010f\u0111\7\4\2\2\u0110\u010f\3\2")
        buf.write("\2\2\u0110\u0111\3\2\2\2\u0111\u0113\3\2\2\2\u0112\u010e")
        buf.write("\3\2\2\2\u0113\u0114\3\2\2\2\u0114\u0112\3\2\2\2\u0114")
        buf.write("\u0115\3\2\2\2\u0115\u0118\3\2\2\2\u0116\u0117\7\r\2\2")
        buf.write("\u0117\u0119\5H%\2\u0118\u0116\3\2\2\2\u0118\u0119\3\2")
        buf.write("\2\2\u0119\u011b\3\2\2\2\u011a\u010a\3\2\2\2\u011a\u010c")
        buf.write("\3\2\2\2\u011b\u011e\3\2\2\2\u011c\u011e\7G\2\2\u011d")
        buf.write("\u0103\3\2\2\2\u011d\u011c\3\2\2\2\u011e\13\3\2\2\2\u011f")
        buf.write("\u0120\7H\2\2\u0120\r\3\2\2\2\u0121\u0123\7\24\2\2\u0122")
        buf.write("\u0124\5\"\22\2\u0123\u0122\3\2\2\2\u0123\u0124\3\2\2")
        buf.write("\2\u0124\u0125\3\2\2\2\u0125\u0128\5H%\2\u0126\u0127\7")
        buf.write("\r\2\2\u0127\u0129\5H%\2\u0128\u0126\3\2\2\2\u0128\u0129")
        buf.write("\3\2\2\2\u0129\u0130\3\2\2\2\u012a\u012c\7\25\2\2\u012b")
        buf.write("\u012d\5\"\22\2\u012c\u012b\3\2\2\2\u012c\u012d\3\2\2")
        buf.write("\2\u012d\u012e\3\2\2\2\u012e\u0130\5H%\2\u012f\u0121\3")
        buf.write("\2\2\2\u012f\u012a\3\2\2\2\u0130\17\3\2\2\2\u0131\u0132")
        buf.write("\t\b\2\2\u0132\u0134\t\t\2\2\u0133\u0135\7\21\2\2\u0134")
        buf.write("\u0133\3\2\2\2\u0134\u0135\3\2\2\2\u0135\u0136\3\2\2\2")
        buf.write("\u0136\u0137\5H%\2\u0137\21\3\2\2\2\u0138\u0191\5\26\f")
        buf.write("\2\u0139\u0149\5$\23\2\u013a\u014a\5\24\13\2\u013b\u0146")
        buf.write("\5H%\2\u013c\u0144\7\r\2\2\u013d\u013e\5H%\2\u013e\u013f")
        buf.write("\7\13\2\2\u013f\u0140\5\34\17\2\u0140\u0141\7\f\2\2\u0141")
        buf.write("\u0142\5\36\20\2\u0142\u0145\3\2\2\2\u0143\u0145\5H%\2")
        buf.write("\u0144\u013d\3\2\2\2\u0144\u0143\3\2\2\2\u0145\u0147\3")
        buf.write("\2\2\2\u0146\u013c\3\2\2\2\u0146\u0147\3\2\2\2\u0147\u014a")
        buf.write("\3\2\2\2\u0148\u014a\5:\36\2\u0149\u013a\3\2\2\2\u0149")
        buf.write("\u013b\3\2\2\2\u0149\u0148\3\2\2\2\u014a\u0191\3\2\2\2")
        buf.write("\u014b\u014d\7\5\2\2\u014c\u014b\3\2\2\2\u014c\u014d\3")
        buf.write("\2\2\2\u014d\u014e\3\2\2\2\u014e\u0150\5(\25\2\u014f\u0151")
        buf.write("\7\13\2\2\u0150\u014f\3\2\2\2\u0150\u0151\3\2\2\2\u0151")
        buf.write("\u0153\3\2\2\2\u0152\u0154\7S\2\2\u0153\u0152\3\2\2\2")
        buf.write("\u0153\u0154\3\2\2\2\u0154\u0157\3\2\2\2\u0155\u0158\5")
        buf.write("*\26\2\u0156\u0158\5\"\22\2\u0157\u0155\3\2\2\2\u0157")
        buf.write("\u0156\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u015a\3\2\2\2")
        buf.write("\u0159\u015b\5H%\2\u015a\u0159\3\2\2\2\u015a\u015b\3\2")
        buf.write("\2\2\u015b\u0171\3\2\2\2\u015c\u015d\7\r\2\2\u015d\u015e")
        buf.write("\5H%\2\u015e\u0160\7\f\2\2\u015f\u0161\5H%\2\u0160\u015f")
        buf.write("\3\2\2\2\u0161\u0162\3\2\2\2\u0162\u0160\3\2\2\2\u0162")
        buf.write("\u0163\3\2\2\2\u0163\u0172\3\2\2\2\u0164\u0166\7\r\2\2")
        buf.write("\u0165\u0164\3\2\2\2\u0165\u0166\3\2\2\2\u0166\u0168\3")
        buf.write("\2\2\2\u0167\u0169\5\60\31\2\u0168\u0167\3\2\2\2\u0168")
        buf.write("\u0169\3\2\2\2\u0169\u016c\3\2\2\2\u016a\u016d\5\62\32")
        buf.write("\2\u016b\u016d\5H%\2\u016c\u016a\3\2\2\2\u016c\u016b\3")
        buf.write("\2\2\2\u016d\u0172\3\2\2\2\u016e\u0172\5\64\33\2\u016f")
        buf.write("\u0172\5\66\34\2\u0170\u0172\58\35\2\u0171\u015c\3\2\2")
        buf.write("\2\u0171\u0165\3\2\2\2\u0171\u016e\3\2\2\2\u0171\u016f")
        buf.write("\3\2\2\2\u0171\u0170\3\2\2\2\u0171\u0172\3\2\2\2\u0172")
        buf.write("\u0191\3\2\2\2\u0173\u0175\t\n\2\2\u0174\u0173\3\2\2\2")
        buf.write("\u0174\u0175\3\2\2\2\u0175\u0176\3\2\2\2\u0176\u017d\5")
        buf.write("\60\31\2\u0177\u017e\5\62\32\2\u0178\u017e\5\30\r\2\u0179")
        buf.write("\u017b\7S\2\2\u017a\u0179\3\2\2\2\u017a\u017b\3\2\2\2")
        buf.write("\u017b\u017c\3\2\2\2\u017c\u017e\5H%\2\u017d\u0177\3\2")
        buf.write("\2\2\u017d\u0178\3\2\2\2\u017d\u017a\3\2\2\2\u017e\u0191")
        buf.write("\3\2\2\2\u017f\u0182\5*\26\2\u0180\u0182\5,\27\2\u0181")
        buf.write("\u017f\3\2\2\2\u0181\u0180\3\2\2\2\u0182\u018b\3\2\2\2")
        buf.write("\u0183\u0185\7\20\2\2\u0184\u0183\3\2\2\2\u0184\u0185")
        buf.write("\3\2\2\2\u0185\u0186\3\2\2\2\u0186\u0189\5H%\2\u0187\u0188")
        buf.write("\7\r\2\2\u0188\u018a\5H%\2\u0189\u0187\3\2\2\2\u0189\u018a")
        buf.write("\3\2\2\2\u018a\u018c\3\2\2\2\u018b\u0184\3\2\2\2\u018b")
        buf.write("\u018c\3\2\2\2\u018c\u0191\3\2\2\2\u018d\u0191\5&\24\2")
        buf.write("\u018e\u0191\5H%\2\u018f\u0191\5\64\33\2\u0190\u0138\3")
        buf.write("\2\2\2\u0190\u0139\3\2\2\2\u0190\u014c\3\2\2\2\u0190\u0174")
        buf.write("\3\2\2\2\u0190\u0181\3\2\2\2\u0190\u018d\3\2\2\2\u0190")
        buf.write("\u018e\3\2\2\2\u0190\u018f\3\2\2\2\u0191\23\3\2\2\2\u0192")
        buf.write("\u0194\5\62\32\2\u0193\u0192\3\2\2\2\u0193\u0194\3\2\2")
        buf.write("\2\u0194\u0195\3\2\2\2\u0195\u019b\t\13\2\2\u0196\u0198")
        buf.write("\7\5\2\2\u0197\u0199\7\37\2\2\u0198\u0197\3\2\2\2\u0198")
        buf.write("\u0199\3\2\2\2\u0199\u019a\3\2\2\2\u019a\u019c\5\62\32")
        buf.write("\2\u019b\u0196\3\2\2\2\u019b\u019c\3\2\2\2\u019c\25\3")
        buf.write("\2\2\2\u019d\u01a1\5$\23\2\u019e\u01a1\5\60\31\2\u019f")
        buf.write("\u01a1\5*\26\2\u01a0\u019d\3\2\2\2\u01a0\u019e\3\2\2\2")
        buf.write("\u01a0\u019f\3\2\2\2\u01a0\u01a1\3\2\2\2\u01a1\u01a4\3")
        buf.write("\2\2\2\u01a2\u01a5\5\30\r\2\u01a3\u01a5\5\32\16\2\u01a4")
        buf.write("\u01a2\3\2\2\2\u01a4\u01a3\3\2\2\2\u01a5\27\3\2\2\2\u01a6")
        buf.write("\u01a8\5\62\32\2\u01a7\u01a9\7\4\2\2\u01a8\u01a7\3\2\2")
        buf.write("\2\u01a8\u01a9\3\2\2\2\u01a9\u01ab\3\2\2\2\u01aa\u01ac")
        buf.write("\t\f\2\2\u01ab\u01aa\3\2\2\2\u01ab\u01ac\3\2\2\2\u01ac")
        buf.write("\u01ae\3\2\2\2\u01ad\u01a6\3\2\2\2\u01ae\u01af\3\2\2\2")
        buf.write("\u01af\u01ad\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b4\3")
        buf.write("\2\2\2\u01b1\u01b4\7!\2\2\u01b2\u01b4\7#\2\2\u01b3\u01ad")
        buf.write("\3\2\2\2\u01b3\u01b1\3\2\2\2\u01b3\u01b2\3\2\2\2\u01b4")
        buf.write("\u01cb\3\2\2\2\u01b5\u01b7\t\r\2\2\u01b6\u01b5\3\2\2\2")
        buf.write("\u01b6\u01b7\3\2\2\2\u01b7\u01ba\3\2\2\2\u01b8\u01bb\5")
        buf.write("*\26\2\u01b9\u01bb\5.\30\2\u01ba\u01b8\3\2\2\2\u01ba\u01b9")
        buf.write("\3\2\2\2\u01ba\u01bb\3\2\2\2\u01bb\u01c6\3\2\2\2\u01bc")
        buf.write("\u01c7\5H%\2\u01bd\u01c0\5@!\2\u01be\u01bf\t\7\2\2\u01bf")
        buf.write("\u01c1\5\34\17\2\u01c0\u01be\3\2\2\2\u01c0\u01c1\3\2\2")
        buf.write("\2\u01c1\u01c4\3\2\2\2\u01c2\u01c3\7\f\2\2\u01c3\u01c5")
        buf.write("\5\36\20\2\u01c4\u01c2\3\2\2\2\u01c4\u01c5\3\2\2\2\u01c5")
        buf.write("\u01c7\3\2\2\2\u01c6\u01bc\3\2\2\2\u01c6\u01bd\3\2\2\2")
        buf.write("\u01c7\u01c9\3\2\2\2\u01c8\u01ca\t\16\2\2\u01c9\u01c8")
        buf.write("\3\2\2\2\u01c9\u01ca\3\2\2\2\u01ca\u01cc\3\2\2\2\u01cb")
        buf.write("\u01b6\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd\u01cb\3\2\2\2")
        buf.write("\u01cd\u01ce\3\2\2\2\u01ce\31\3\2\2\2\u01cf\u01d2\5\66")
        buf.write("\34\2\u01d0\u01d2\5\62\32\2\u01d1\u01cf\3\2\2\2\u01d1")
        buf.write("\u01d0\3\2\2\2\u01d2\u01d4\3\2\2\2\u01d3\u01d5\7\4\2\2")
        buf.write("\u01d4\u01d3\3\2\2\2\u01d4\u01d5\3\2\2\2\u01d5\u01d7\3")
        buf.write("\2\2\2\u01d6\u01d1\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8\u01d6")
        buf.write("\3\2\2\2\u01d8\u01d9\3\2\2\2\u01d9\u01db\3\2\2\2\u01da")
        buf.write("\u01dc\7\r\2\2\u01db\u01da\3\2\2\2\u01db\u01dc\3\2\2\2")
        buf.write("\u01dc\u01dd\3\2\2\2\u01dd\u01e0\5B\"\2\u01de\u01df\t")
        buf.write("\7\2\2\u01df\u01e1\5\34\17\2\u01e0\u01de\3\2\2\2\u01e0")
        buf.write("\u01e1\3\2\2\2\u01e1\u01e4\3\2\2\2\u01e2\u01e3\7\f\2\2")
        buf.write("\u01e3\u01e5\5\36\20\2\u01e4\u01e2\3\2\2\2\u01e4\u01e5")
        buf.write("\3\2\2\2\u01e5\33\3\2\2\2\u01e6\u01e8\7S\2\2\u01e7\u01e6")
        buf.write("\3\2\2\2\u01e7\u01e8\3\2\2\2\u01e8\u01eb\3\2\2\2\u01e9")
        buf.write("\u01ec\5*\26\2\u01ea\u01ec\5.\30\2\u01eb\u01e9\3\2\2\2")
        buf.write("\u01eb\u01ea\3\2\2\2\u01eb\u01ec\3\2\2\2\u01ec\u01ee\3")
        buf.write("\2\2\2\u01ed\u01ef\5D#\2\u01ee\u01ed\3\2\2\2\u01ee\u01ef")
        buf.write("\3\2\2\2\u01ef\u01f1\3\2\2\2\u01f0\u01f2\7\r\2\2\u01f1")
        buf.write("\u01f0\3\2\2\2\u01f1\u01f2\3\2\2\2\u01f2\u01f6\3\2\2\2")
        buf.write("\u01f3\u01f7\5D#\2\u01f4\u01f7\5F$\2\u01f5\u01f7\5\24")
        buf.write("\13\2\u01f6\u01f3\3\2\2\2\u01f6\u01f4\3\2\2\2\u01f6\u01f5")
        buf.write("\3\2\2\2\u01f7\u01f8\3\2\2\2\u01f8\u01f6\3\2\2\2\u01f8")
        buf.write("\u01f9\3\2\2\2\u01f9\35\3\2\2\2\u01fa\u01fc\7S\2\2\u01fb")
        buf.write("\u01fa\3\2\2\2\u01fb\u01fc\3\2\2\2\u01fc\u01ff\3\2\2\2")
        buf.write("\u01fd\u0200\5*\26\2\u01fe\u0200\5.\30\2\u01ff\u01fd\3")
        buf.write("\2\2\2\u01ff\u01fe\3\2\2\2\u01ff\u0200\3\2\2\2\u0200\u0208")
        buf.write("\3\2\2\2\u0201\u0204\5D#\2\u0202\u0204\5F$\2\u0203\u0201")
        buf.write("\3\2\2\2\u0203\u0202\3\2\2\2\u0204\u0206\3\2\2\2\u0205")
        buf.write("\u0207\7\4\2\2\u0206\u0205\3\2\2\2\u0206\u0207\3\2\2\2")
        buf.write("\u0207\u0209\3\2\2\2\u0208\u0203\3\2\2\2\u0209\u020a\3")
        buf.write("\2\2\2\u020a\u0208\3\2\2\2\u020a\u020b\3\2\2\2\u020b\37")
        buf.write("\3\2\2\2\u020c\u020d\5H%\2\u020d\u020e\5\60\31\2\u020e")
        buf.write("\u020f\5\62\32\2\u020f\u021e\3\2\2\2\u0210\u021e\5\26")
        buf.write("\f\2\u0211\u0212\5$\23\2\u0212\u0213\5H%\2\u0213\u021e")
        buf.write("\3\2\2\2\u0214\u0215\5\60\31\2\u0215\u0216\5H%\2\u0216")
        buf.write("\u021e\3\2\2\2\u0217\u0218\5,\27\2\u0218\u021b\5H%\2\u0219")
        buf.write("\u021a\7\r\2\2\u021a\u021c\5H%\2\u021b\u0219\3\2\2\2\u021b")
        buf.write("\u021c\3\2\2\2\u021c\u021e\3\2\2\2\u021d\u020c\3\2\2\2")
        buf.write("\u021d\u0210\3\2\2\2\u021d\u0211\3\2\2\2\u021d\u0214\3")
        buf.write("\2\2\2\u021d\u0217\3\2\2\2\u021e!\3\2\2\2\u021f\u0220")
        buf.write("\7K\2\2\u0220#\3\2\2\2\u0221\u0222\7L\2\2\u0222%\3\2\2")
        buf.write("\2\u0223\u022a\7\b\2\2\u0224\u0227\5H%\2\u0225\u0226\7")
        buf.write("\r\2\2\u0226\u0228\5H%\2\u0227\u0225\3\2\2\2\u0227\u0228")
        buf.write("\3\2\2\2\u0228\u022b\3\2\2\2\u0229\u022b\5:\36\2\u022a")
        buf.write("\u0224\3\2\2\2\u022a\u0229\3\2\2\2\u022b\'\3\2\2\2\u022c")
        buf.write("\u022d\7M\2\2\u022d)\3\2\2\2\u022e\u022f\7N\2\2\u022f")
        buf.write("+\3\2\2\2\u0230\u0231\7O\2\2\u0231-\3\2\2\2\u0232\u0233")
        buf.write("\7P\2\2\u0233/\3\2\2\2\u0234\u0235\7Q\2\2\u0235\61\3\2")
        buf.write("\2\2\u0236\u0237\7%\2\2\u0237\u023b\7S\2\2\u0238\u0239")
        buf.write("\7&\2\2\u0239\u023b\7S\2\2\u023a\u0236\3\2\2\2\u023a\u0238")
        buf.write("\3\2\2\2\u023b\63\3\2\2\2\u023c\u023d\7\'\2\2\u023d\u023e")
        buf.write("\7S\2\2\u023e\65\3\2\2\2\u023f\u0240\7(\2\2\u0240\u0241")
        buf.write("\7S\2\2\u0241\67\3\2\2\2\u0242\u0243\7&\2\2\u0243\u0244")
        buf.write("\7S\2\2\u02449\3\2\2\2\u0245\u0246\5\62\32\2\u0246\u0247")
        buf.write("\t\17\2\2\u0247;\3\2\2\2\u0248\u0249\7+\2\2\u0249=\3\2")
        buf.write("\2\2\u024a\u024b\5\62\32\2\u024b\u024c\7,\2\2\u024c\u0254")
        buf.write("\3\2\2\2\u024d\u024e\7,\2\2\u024e\u024f\5\62\32\2\u024f")
        buf.write("\u0250\7\23\2\2\u0250\u0251\5\62\32\2\u0251\u0252\7-\2")
        buf.write("\2\u0252\u0254\3\2\2\2\u0253\u024a\3\2\2\2\u0253\u024d")
        buf.write("\3\2\2\2\u0254?\3\2\2\2\u0255\u0256\7.\2\2\u0256\u0257")
        buf.write("\7S\2\2\u0257A\3\2\2\2\u0258\u0259\7/\2\2\u0259\u025a")
        buf.write("\7S\2\2\u025a\u025b\7R\2\2\u025bC\3\2\2\2\u025c\u025d")
        buf.write("\7\60\2\2\u025d\u0261\7S\2\2\u025e\u025f\7\61\2\2\u025f")
        buf.write("\u0261\7S\2\2\u0260\u025c\3\2\2\2\u0260\u025e\3\2\2\2")
        buf.write("\u0261E\3\2\2\2\u0262\u0263\7\62\2\2\u0263\u0264\7S\2")
        buf.write("\2\u0264G\3\2\2\2\u0265\u0266\7\63\2\2\u0266\u0267\7S")
        buf.write("\2\2\u0267\u029b\7R\2\2\u0268\u0269\7\60\2\2\u0269\u029b")
        buf.write("\7S\2\2\u026a\u026b\7\64\2\2\u026b\u026c\7S\2\2\u026c")
        buf.write("\u029b\7R\2\2\u026d\u026e\7\62\2\2\u026e\u029b\7S\2\2")
        buf.write("\u026f\u0270\7\65\2\2\u0270\u0271\7S\2\2\u0271\u029b\7")
        buf.write("R\2\2\u0272\u0273\7\66\2\2\u0273\u0274\7S\2\2\u0274\u029b")
        buf.write("\7R\2\2\u0275\u0276\7\67\2\2\u0276\u0277\7S\2\2\u0277")
        buf.write("\u029b\7R\2\2\u0278\u0279\78\2\2\u0279\u027a\7S\2\2\u027a")
        buf.write("\u029b\7R\2\2\u027b\u027c\79\2\2\u027c\u027d\7S\2\2\u027d")
        buf.write("\u029b\7R\2\2\u027e\u027f\7:\2\2\u027f\u029b\7S\2\2\u0280")
        buf.write("\u0281\7;\2\2\u0281\u0282\7S\2\2\u0282\u029b\7R\2\2\u0283")
        buf.write("\u0284\7<\2\2\u0284\u0285\7S\2\2\u0285\u029b\7R\2\2\u0286")
        buf.write("\u0287\7=\2\2\u0287\u0288\7S\2\2\u0288\u029b\7R\2\2\u0289")
        buf.write("\u028a\7>\2\2\u028a\u028b\7S\2\2\u028b\u029b\7R\2\2\u028c")
        buf.write("\u028d\7?\2\2\u028d\u028e\7S\2\2\u028e\u029b\7R\2\2\u028f")
        buf.write("\u0290\7@\2\2\u0290\u0291\7S\2\2\u0291\u029b\7R\2\2\u0292")
        buf.write("\u0293\7A\2\2\u0293\u0294\7S\2\2\u0294\u029b\7R\2\2\u0295")
        buf.write("\u0296\7B\2\2\u0296\u0297\7S\2\2\u0297\u029b\7R\2\2\u0298")
        buf.write("\u0299\7C\2\2\u0299\u029b\7S\2\2\u029a\u0265\3\2\2\2\u029a")
        buf.write("\u0268\3\2\2\2\u029a\u026a\3\2\2\2\u029a\u026d\3\2\2\2")
        buf.write("\u029a\u026f\3\2\2\2\u029a\u0272\3\2\2\2\u029a\u0275\3")
        buf.write("\2\2\2\u029a\u0278\3\2\2\2\u029a\u027b\3\2\2\2\u029a\u027e")
        buf.write("\3\2\2\2\u029a\u0280\3\2\2\2\u029a\u0283\3\2\2\2\u029a")
        buf.write("\u0286\3\2\2\2\u029a\u0289\3\2\2\2\u029a\u028c\3\2\2\2")
        buf.write("\u029a\u028f\3\2\2\2\u029a\u0292\3\2\2\2\u029a\u0295\3")
        buf.write("\2\2\2\u029a\u0298\3\2\2\2\u029bI\3\2\2\2\u029c\u02a4")
        buf.write("\5\24\13\2\u029d\u02a0\5H%\2\u029e\u029f\7\r\2\2\u029f")
        buf.write("\u02a1\5H%\2\u02a0\u029e\3\2\2\2\u02a0\u02a1\3\2\2\2\u02a1")
        buf.write("\u02a4\3\2\2\2\u02a2\u02a4\5> \2\u02a3\u029c\3\2\2\2\u02a3")
        buf.write("\u029d\3\2\2\2\u02a3\u02a2\3\2\2\2\u02a4K\3\2\2\2\u02a5")
        buf.write("\u02a6\7\61\2\2\u02a6\u02a9\7S\2\2\u02a7\u02a9\7D\2\2")
        buf.write("\u02a8\u02a5\3\2\2\2\u02a8\u02a7\3\2\2\2\u02a9M\3\2\2")
        buf.write("\2\u02aa\u02ab\7\'\2\2\u02ab\u02ac\7S\2\2\u02acO\3\2\2")
        buf.write("\2}TY\\^behjosw|~\u0081\u0084\u0088\u008b\u008e\u0092")
        buf.write("\u0096\u009a\u009e\u00a2\u00a5\u00a7\u00b0\u00b3\u00b7")
        buf.write("\u00bb\u00bf\u00c2\u00c6\u00ca\u00ce\u00d2\u00d5\u00da")
        buf.write("\u00dd\u00e2\u00e6\u00e9\u00ee\u00f2\u00f7\u00fe\u0105")
        buf.write("\u0108\u010c\u0110\u0114\u0118\u011a\u011d\u0123\u0128")
        buf.write("\u012c\u012f\u0134\u0144\u0146\u0149\u014c\u0150\u0153")
        buf.write("\u0157\u015a\u0162\u0165\u0168\u016c\u0171\u0174\u017a")
        buf.write("\u017d\u0181\u0184\u0189\u018b\u0190\u0193\u0198\u019b")
        buf.write("\u01a0\u01a4\u01a8\u01ab\u01af\u01b3\u01b6\u01ba\u01c0")
        buf.write("\u01c4\u01c6\u01c9\u01cd\u01d1\u01d4\u01d8\u01db\u01e0")
        buf.write("\u01e4\u01e7\u01eb\u01ee\u01f1\u01f6\u01f8\u01fb\u01ff")
        buf.write("\u0203\u0206\u020a\u021b\u021d\u0227\u022a\u023a\u0253")
        buf.write("\u0260\u029a\u02a0\u02a3\u02a8")
        return buf.getvalue()


class GeoAnQuParser ( Parser ):

    grammarFileName = "GeoAnQu.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'that'", "'and'", "'with'", "'for each'", 
                     "'per'", "'in'", "'near'", "'on'", "'from'", "'to'", 
                     "'of'", "'for'", "'during'", "'each'", "'new'", "'through'", 
                     "'by'", "'weighted by'", "'with similar'", "'best site'", 
                     "'best sites'", "'grids'", "'grid cells'", "'grid'", 
                     "'grid cell'", "'hexagonal grids'", "'hexagonal grid'", 
                     "'hexagon grid'", "'diameter of'", "'area'", "'buffer area'", 
                     "'distance'", "'buffer areas'", "'or'", "'equantity'", 
                     "'epercent'", "'edate'", "'etime'", "'circle'", "'rectangle'", 
                     "'nearest neighbors'", "'distance band'", "'increments'", 
                     "'network'", "'networkquality'", "'object'", "'placename'", 
                     "'event'", "'field'", "'objectquality'", "'eventquality'", 
                     "'objconamount'", "'eveconamount'", "'conamount'", 
                     "'covamount'", "'amount'", "'objconobjconpro'", "'eveconobjconpro'", 
                     "'objconobjcovpro'", "'eveconobjcovpro'", "'conconpro'", 
                     "'concovpro'", "'covpro'", "'proportion'", "'concept'", 
                     "'world'", "<INVALID>", "'where'", "<INVALID>", "'how many'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "WH", "Location1", 
                      "Location2", "ConAm", "AUX", "Flase", "Aggregate", 
                      "TOPO", "Boolean", "Extrema", "Distance", "ExtreDist", 
                      "Compare", "ML", "DIGIT", "WS", "COMMA" ]

    RULE_start = 0
    RULE_false = 1
    RULE_measure = 2
    RULE_measure1 = 3
    RULE_location = 4
    RULE_conAm = 5
    RULE_weight = 6
    RULE_allocation = 7
    RULE_condition = 8
    RULE_grid = 9
    RULE_boolField = 10
    RULE_distField = 11
    RULE_serviceObj = 12
    RULE_origin = 13
    RULE_destination = 14
    RULE_subcon = 15
    RULE_aggre = 16
    RULE_topoR = 17
    RULE_topoRIn = 18
    RULE_boolR = 19
    RULE_extremaR = 20
    RULE_distanceR = 21
    RULE_extreDist = 22
    RULE_compareR = 23
    RULE_quantity = 24
    RULE_date = 25
    RULE_time = 26
    RULE_percent = 27
    RULE_densityNei = 28
    RULE_distBandNei = 29
    RULE_distBand = 30
    RULE_networkC = 31
    RULE_networkQ = 32
    RULE_objectC = 33
    RULE_eventC = 34
    RULE_coreC = 35
    RULE_support = 36
    RULE_extent = 37
    RULE_temEx = 38

    ruleNames =  [ "start", "false", "measure", "measure1", "location", 
                   "conAm", "weight", "allocation", "condition", "grid", 
                   "boolField", "distField", "serviceObj", "origin", "destination", 
                   "subcon", "aggre", "topoR", "topoRIn", "boolR", "extremaR", 
                   "distanceR", "extreDist", "compareR", "quantity", "date", 
                   "time", "percent", "densityNei", "distBandNei", "distBand", 
                   "networkC", "networkQ", "objectC", "eventC", "coreC", 
                   "support", "extent", "temEx" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    WH=67
    Location1=68
    Location2=69
    ConAm=70
    AUX=71
    Flase=72
    Aggregate=73
    TOPO=74
    Boolean=75
    Extrema=76
    Distance=77
    ExtreDist=78
    Compare=79
    ML=80
    DIGIT=81
    WS=82
    COMMA=83

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ConditionContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ConditionContext,i)


        def measure1(self):
            return self.getTypedRuleContext(GeoAnQuParser.Measure1Context,0)


        def subcon(self):
            return self.getTypedRuleContext(GeoAnQuParser.SubconContext,0)


        def support(self):
            return self.getTypedRuleContext(GeoAnQuParser.SupportContext,0)


        def temEx(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TemExContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TemExContext,i)


        def WH(self):
            return self.getToken(GeoAnQuParser.WH, 0)

        def measure(self):
            return self.getTypedRuleContext(GeoAnQuParser.MeasureContext,0)


        def false(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.FalseContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.FalseContext,i)


        def extent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtentContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtentContext,i)


        def AUX(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.AUX)
            else:
                return self.getToken(GeoAnQuParser.AUX, i)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = GeoAnQuParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.WH]:
                self.state = 78
                self.match(GeoAnQuParser.WH)
                self.state = 92
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.AUX]:
                    self.state = 79
                    self.match(GeoAnQuParser.AUX)
                    self.state = 82
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 80
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 81
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                        pass
                    else:
                        pass
                    self.state = 84
                    self.measure()
                    pass
                elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                    self.state = 85
                    self.measure()
                    self.state = 87
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 86
                        self.match(GeoAnQuParser.AUX)


                    self.state = 90
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                    if la_ == 1:
                        self.state = 89
                        self.false()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                self.state = 94
                self.measure()
                self.state = 96
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 95
                    self.match(GeoAnQuParser.T__0)


                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 98
                    self.match(GeoAnQuParser.AUX)


                self.state = 102
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 101
                    self.false()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 113
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 106
                    self.condition()
                    self.state = 109
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        self.state = 107
                        self.match(GeoAnQuParser.T__1)

                    elif la_ == 2:
                        self.state = 108
                        self.false()

             
                self.state = 115
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__9:
                self.state = 116
                self.measure1()


            self.state = 130
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 124
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__2]:
                    self.state = 119
                    self.match(GeoAnQuParser.T__2)
                    pass
                elif token in [GeoAnQuParser.T__0]:
                    self.state = 120
                    self.match(GeoAnQuParser.T__0)
                    self.state = 122
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 121
                        self.match(GeoAnQuParser.AUX)


                    pass
                elif token in [GeoAnQuParser.T__30, GeoAnQuParser.T__32, GeoAnQuParser.T__34, GeoAnQuParser.T__35, GeoAnQuParser.T__37, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64, GeoAnQuParser.Flase, GeoAnQuParser.TOPO, GeoAnQuParser.Extrema, GeoAnQuParser.Distance, GeoAnQuParser.Compare]:
                    pass
                else:
                    pass
                self.state = 127
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 126
                    self.false()


                self.state = 129
                self.subcon()


            self.state = 134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4:
                self.state = 132
                _la = self._input.LA(1)
                if not(_la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 133
                self.support()


            self.state = 137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 136
                self.condition()


            self.state = 152
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 140
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6:
                        self.state = 139
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 146 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 142
                            self.extent()
                            self.state = 144
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 143
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 148 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
             
                self.state = 154
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__36))) != 0):
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0):
                    self.state = 155
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 158
                self.temEx()
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__9:
                    self.state = 159
                    self.match(GeoAnQuParser.T__9)


                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__36:
                    self.state = 162
                    self.temEx()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FalseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Flase(self):
            return self.getToken(GeoAnQuParser.Flase, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_false

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalse" ):
                listener.enterFalse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalse" ):
                listener.exitFalse(self)




    def false(self):

        localctx = GeoAnQuParser.FalseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_false)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(GeoAnQuParser.Flase)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MeasureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def location(self):
            return self.getTypedRuleContext(GeoAnQuParser.LocationContext,0)


        def conAm(self):
            return self.getTypedRuleContext(GeoAnQuParser.ConAmContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.DIGIT)
            else:
                return self.getToken(GeoAnQuParser.DIGIT, i)

        def weight(self):
            return self.getTypedRuleContext(GeoAnQuParser.WeightContext,0)


        def distBandNei(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DistBandNeiContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DistBandNeiContext,i)


        def extreDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtreDistContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,i)


        def networkC(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,0)


        def networkQ(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkQContext,0)


        def destination(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DestinationContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,i)


        def origin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.OriginContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.OriginContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure" ):
                listener.enterMeasure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure" ):
                listener.exitMeasure(self)




    def measure(self):

        localctx = GeoAnQuParser.MeasureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_measure)
        self._la = 0 # Token type
        try:
            self.state = 252
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 169
                self.location()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.conAm()
                self.state = 171
                self.coreC()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 173
                    self.aggre()


                self.state = 177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 176
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 183 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 179
                        self.coreC()
                        self.state = 181
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__1:
                            self.state = 180
                            self.match(GeoAnQuParser.T__1)



                    else:
                        raise NoViableAltException(self)
                    self.state = 185 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                self.state = 204
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 187
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11) | (1 << GeoAnQuParser.T__12))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 189
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.DIGIT:
                            self.state = 188
                            self.match(GeoAnQuParser.DIGIT)


                        self.state = 192
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__13:
                            self.state = 191
                            self.match(GeoAnQuParser.T__13)


                        self.state = 196
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [GeoAnQuParser.T__14]:
                            self.state = 194
                            self.match(GeoAnQuParser.T__14)
                            pass
                        elif token in [GeoAnQuParser.ExtreDist]:
                            self.state = 195
                            self.extreDist()
                            pass
                        elif token in [GeoAnQuParser.T__40, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                            pass
                        else:
                            pass
                        self.state = 200
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                            self.state = 198
                            self.coreC()
                            pass
                        elif token in [GeoAnQuParser.T__40]:
                            self.state = 199
                            self.distBandNei()
                            pass
                        else:
                            raise NoViableAltException(self)
                 
                    self.state = 206
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__17 or _la==GeoAnQuParser.T__18:
                    self.state = 207
                    self.weight()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 211
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 210
                    self.aggre()


                self.state = 216
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__43]:
                    self.state = 213
                    self.networkC()
                    pass
                elif token in [GeoAnQuParser.T__44]:
                    self.state = 214
                    self.networkQ()
                    pass
                elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                    self.state = 215
                    self.coreC()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 224
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 219
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__15:
                            self.state = 218
                            _la = self._input.LA(1)
                            if not(_la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__15):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 221
                        self.destination() 
                    self.state = 226
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

                self.state = 236
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 228
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                        if la_ == 1:
                            self.state = 227
                            _la = self._input.LA(1)
                            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 231
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__13:
                            self.state = 230
                            self.match(GeoAnQuParser.T__13)


                        self.state = 233
                        self.origin() 
                    self.state = 238
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

                self.state = 245
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 240
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9:
                            self.state = 239
                            self.match(GeoAnQuParser.T__9)


                        self.state = 242
                        self.destination() 
                    self.state = 247
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 248
                self.coreC()
                self.state = 249
                self.match(GeoAnQuParser.T__16)
                self.state = 250
                self.networkC()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Measure1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure1" ):
                listener.enterMeasure1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure1" ):
                listener.exitMeasure1(self)




    def measure1(self):

        localctx = GeoAnQuParser.Measure1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_measure1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(GeoAnQuParser.T__9)
            self.state = 255
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Location1(self):
            return self.getToken(GeoAnQuParser.Location1, 0)

        def allocation(self):
            return self.getTypedRuleContext(GeoAnQuParser.AllocationContext,0)


        def AUX(self):
            return self.getToken(GeoAnQuParser.AUX, 0)

        def false(self):
            return self.getTypedRuleContext(GeoAnQuParser.FalseContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def Location2(self):
            return self.getToken(GeoAnQuParser.Location2, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)




    def location(self):

        localctx = GeoAnQuParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.state = 283
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Location1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 257
                self.match(GeoAnQuParser.Location1)
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 258
                    self.match(GeoAnQuParser.AUX)


                self.state = 262
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 261
                    self.false()


                self.state = 280
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__19, GeoAnQuParser.T__20]:
                    self.state = 264
                    self.allocation()
                    pass
                elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64, GeoAnQuParser.Extrema]:
                    self.state = 266
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Extrema:
                        self.state = 265
                        self.extremaR()


                    self.state = 272 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 268
                            self.coreC()
                            self.state = 270
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 269
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 274 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

                    self.state = 278
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
                    if la_ == 1:
                        self.state = 276
                        self.match(GeoAnQuParser.T__10)
                        self.state = 277
                        self.coreC()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.Location2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 282
                self.match(GeoAnQuParser.Location2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConAmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ConAm(self):
            return self.getToken(GeoAnQuParser.ConAm, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_conAm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConAm" ):
                listener.enterConAm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConAm" ):
                listener.exitConAm(self)




    def conAm(self):

        localctx = GeoAnQuParser.ConAmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_conAm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(GeoAnQuParser.ConAm)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WeightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_weight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeight" ):
                listener.enterWeight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeight" ):
                listener.exitWeight(self)




    def weight(self):

        localctx = GeoAnQuParser.WeightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_weight)
        self._la = 0 # Token type
        try:
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 287
                self.match(GeoAnQuParser.T__17)
                self.state = 289
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 288
                    self.aggre()


                self.state = 291
                self.coreC()
                self.state = 294
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 292
                    self.match(GeoAnQuParser.T__10)
                    self.state = 293
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 296
                self.match(GeoAnQuParser.T__18)
                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 297
                    self.aggre()


                self.state = 300
                self.coreC()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_allocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllocation" ):
                listener.enterAllocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllocation" ):
                listener.exitAllocation(self)




    def allocation(self):

        localctx = GeoAnQuParser.AllocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_allocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__19 or _la==GeoAnQuParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 304
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__10 or _la==GeoAnQuParser.T__11):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__14:
                self.state = 305
                self.match(GeoAnQuParser.T__14)


            self.state = 308
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolField(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolFieldContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def origin(self):
            return self.getTypedRuleContext(GeoAnQuParser.OriginContext,0)


        def destination(self):
            return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,0)


        def boolR(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolRContext,0)


        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def date(self):
            return self.getTypedRuleContext(GeoAnQuParser.DateContext,0)


        def time(self):
            return self.getTypedRuleContext(GeoAnQuParser.TimeContext,0)


        def percent(self):
            return self.getTypedRuleContext(GeoAnQuParser.PercentContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def topoRIn(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRInContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = GeoAnQuParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 398
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 310
                self.boolField()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 311
                self.topoR()
                self.state = 327
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 312
                    self.grid()
                    pass

                elif la_ == 2:
                    self.state = 313
                    self.coreC()
                    self.state = 324
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                    if la_ == 1:
                        self.state = 314
                        self.match(GeoAnQuParser.T__10)
                        self.state = 322
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                        if la_ == 1:
                            self.state = 315
                            self.coreC()
                            self.state = 316
                            self.match(GeoAnQuParser.T__8)
                            self.state = 317
                            self.origin()
                            self.state = 318
                            self.match(GeoAnQuParser.T__9)
                            self.state = 319
                            self.destination()
                            pass

                        elif la_ == 2:
                            self.state = 321
                            self.coreC()
                            pass




                    pass

                elif la_ == 3:
                    self.state = 326
                    self.densityNei()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 330
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2:
                    self.state = 329
                    self.match(GeoAnQuParser.T__2)


                self.state = 332
                self.boolR()
                self.state = 334
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 333
                    self.match(GeoAnQuParser.T__8)


                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 336
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 341
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                if la_ == 1:
                    self.state = 339
                    self.extremaR()

                elif la_ == 2:
                    self.state = 340
                    self.aggre()


                self.state = 344
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 343
                    self.coreC()


                self.state = 367
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 346
                    self.match(GeoAnQuParser.T__10)
                    self.state = 347
                    self.coreC()
                    self.state = 348
                    self.match(GeoAnQuParser.T__9)
                    self.state = 350 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 349
                            self.coreC()

                        else:
                            raise NoViableAltException(self)
                        self.state = 352 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,66,self._ctx)


                elif la_ == 2:
                    self.state = 355
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__10:
                        self.state = 354
                        self.match(GeoAnQuParser.T__10)


                    self.state = 358
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Compare:
                        self.state = 357
                        self.compareR()


                    self.state = 362
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                        self.state = 360
                        self.quantity()
                        pass
                    elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                        self.state = 361
                        self.coreC()
                        pass
                    else:
                        raise NoViableAltException(self)


                elif la_ == 3:
                    self.state = 364
                    self.date()

                elif la_ == 4:
                    self.state = 365
                    self.time()

                elif la_ == 5:
                    self.state = 366
                    self.percent()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 370
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10:
                    self.state = 369
                    _la = self._input.LA(1)
                    if not(_la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 372
                self.compareR()
                self.state = 379
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 373
                    self.quantity()
                    pass

                elif la_ == 2:
                    self.state = 374
                    self.distField()
                    pass

                elif la_ == 3:
                    self.state = 376
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.DIGIT:
                        self.state = 375
                        self.match(GeoAnQuParser.DIGIT)


                    self.state = 378
                    self.coreC()
                    pass


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 383
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.Extrema]:
                    self.state = 381
                    self.extremaR()
                    pass
                elif token in [GeoAnQuParser.Distance]:
                    self.state = 382
                    self.distanceR()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 393
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 386
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__13:
                        self.state = 385
                        self.match(GeoAnQuParser.T__13)


                    self.state = 388
                    self.coreC()
                    self.state = 391
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                    if la_ == 1:
                        self.state = 389
                        self.match(GeoAnQuParser.T__10)
                        self.state = 390
                        self.coreC()




                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 395
                self.topoRIn()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 396
                self.coreC()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 397
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GridContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_grid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrid" ):
                listener.enterGrid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrid" ):
                listener.exitGrid(self)




    def grid(self):

        localctx = GeoAnQuParser.GridContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_grid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__34 or _la==GeoAnQuParser.T__35:
                self.state = 400
                self.quantity()


            self.state = 403
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__21) | (1 << GeoAnQuParser.T__22) | (1 << GeoAnQuParser.T__23) | (1 << GeoAnQuParser.T__24) | (1 << GeoAnQuParser.T__25) | (1 << GeoAnQuParser.T__26) | (1 << GeoAnQuParser.T__27))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                self.state = 404
                self.match(GeoAnQuParser.T__2)
                self.state = 406
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__28:
                    self.state = 405
                    self.match(GeoAnQuParser.T__28)


                self.state = 408
                self.quantity()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def serviceObj(self):
            return self.getTypedRuleContext(GeoAnQuParser.ServiceObjContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_boolField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolField" ):
                listener.enterBoolField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolField" ):
                listener.exitBoolField(self)




    def boolField(self):

        localctx = GeoAnQuParser.BoolFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_boolField)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.TOPO]:
                self.state = 411
                self.topoR()
                pass
            elif token in [GeoAnQuParser.Compare]:
                self.state = 412
                self.compareR()
                pass
            elif token in [GeoAnQuParser.Extrema]:
                self.state = 413
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.T__30, GeoAnQuParser.T__32, GeoAnQuParser.T__34, GeoAnQuParser.T__35, GeoAnQuParser.T__37]:
                pass
            else:
                pass
            self.state = 418
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.state = 416
                self.distField()
                pass

            elif la_ == 2:
                self.state = 417
                self.serviceObj()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def extremaR(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtremaRContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,i)


        def extreDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtreDistContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,i)


        def networkC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.NetworkCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,i)


        def origin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.OriginContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.OriginContext,i)


        def destination(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DestinationContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistField" ):
                listener.enterDistField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistField" ):
                listener.exitDistField(self)




    def distField(self):

        localctx = GeoAnQuParser.DistFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_distField)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.state = 427 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 420
                    self.quantity()
                    self.state = 422
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__1:
                        self.state = 421
                        self.match(GeoAnQuParser.T__1)


                    self.state = 425
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__29) | (1 << GeoAnQuParser.T__30) | (1 << GeoAnQuParser.T__31) | (1 << GeoAnQuParser.T__32))) != 0):
                        self.state = 424
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__29) | (1 << GeoAnQuParser.T__30) | (1 << GeoAnQuParser.T__31) | (1 << GeoAnQuParser.T__32))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 429 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==GeoAnQuParser.T__34 or _la==GeoAnQuParser.T__35):
                        break

                pass
            elif token in [GeoAnQuParser.T__30]:
                self.state = 431
                self.match(GeoAnQuParser.T__30)
                pass
            elif token in [GeoAnQuParser.T__32]:
                self.state = 432
                self.match(GeoAnQuParser.T__32)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 457 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 436
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10))) != 0):
                        self.state = 435
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 440
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 438
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 439
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                        pass
                    else:
                        pass
                    self.state = 452
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                        self.state = 442
                        self.coreC()
                        pass
                    elif token in [GeoAnQuParser.T__43]:
                        self.state = 443
                        self.networkC()
                        self.state = 446
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                        if la_ == 1:
                            self.state = 444
                            _la = self._input.LA(1)
                            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 445
                            self.origin()


                        self.state = 450
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                        if la_ == 1:
                            self.state = 448
                            self.match(GeoAnQuParser.T__9)
                            self.state = 449
                            self.destination()


                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 455
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                    if la_ == 1:
                        self.state = 454
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__1 or _la==GeoAnQuParser.T__33):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()



                else:
                    raise NoViableAltException(self)
                self.state = 459 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServiceObjContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def networkQ(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkQContext,0)


        def origin(self):
            return self.getTypedRuleContext(GeoAnQuParser.OriginContext,0)


        def destination(self):
            return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,0)


        def time(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TimeContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TimeContext,i)


        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_serviceObj

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServiceObj" ):
                listener.enterServiceObj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServiceObj" ):
                listener.exitServiceObj(self)




    def serviceObj(self):

        localctx = GeoAnQuParser.ServiceObjContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_serviceObj)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 463
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__37]:
                    self.state = 461
                    self.time()
                    pass
                elif token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                    self.state = 462
                    self.quantity()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 466
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__1:
                    self.state = 465
                    self.match(GeoAnQuParser.T__1)


                self.state = 470 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__34) | (1 << GeoAnQuParser.T__35) | (1 << GeoAnQuParser.T__37))) != 0)):
                    break

            self.state = 473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__10:
                self.state = 472
                self.match(GeoAnQuParser.T__10)


            self.state = 475
            self.networkQ()
            self.state = 478
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 476
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 477
                self.origin()


            self.state = 482
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 480
                self.match(GeoAnQuParser.T__9)
                self.state = 481
                self.destination()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OriginContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def grid(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.GridContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.GridContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_origin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrigin" ):
                listener.enterOrigin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrigin" ):
                listener.exitOrigin(self)




    def origin(self):

        localctx = GeoAnQuParser.OriginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_origin)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 484
                self.match(GeoAnQuParser.DIGIT)


            self.state = 489
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 487
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 488
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__10, GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__27, GeoAnQuParser.T__34, GeoAnQuParser.T__35, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47]:
                pass
            else:
                pass
            self.state = 492
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 491
                self.objectC()


            self.state = 495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__10:
                self.state = 494
                self.match(GeoAnQuParser.T__10)


            self.state = 500 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 500
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46]:
                        self.state = 497
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__47]:
                        self.state = 498
                        self.eventC()
                        pass
                    elif token in [GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__27, GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                        self.state = 499
                        self.grid()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 502 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_destination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestination" ):
                listener.enterDestination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestination" ):
                listener.exitDestination(self)




    def destination(self):

        localctx = GeoAnQuParser.DestinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_destination)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 505
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 504
                self.match(GeoAnQuParser.DIGIT)


            self.state = 509
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 507
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 508
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47]:
                pass
            else:
                pass
            self.state = 518 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 513
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46]:
                        self.state = 511
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__47]:
                        self.state = 512
                        self.eventC()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 516
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                    if la_ == 1:
                        self.state = 515
                        self.match(GeoAnQuParser.T__1)



                else:
                    raise NoViableAltException(self)
                self.state = 520 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,111,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubconContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def boolField(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolFieldContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_subcon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubcon" ):
                listener.enterSubcon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubcon" ):
                listener.exitSubcon(self)




    def subcon(self):

        localctx = GeoAnQuParser.SubconContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_subcon)
        try:
            self.state = 539
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 522
                self.coreC()
                self.state = 523
                self.compareR()
                self.state = 524
                self.quantity()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 526
                self.boolField()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 527
                self.topoR()
                self.state = 528
                self.coreC()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 530
                self.compareR()
                self.state = 531
                self.coreC()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 533
                self.distanceR()
                self.state = 534
                self.coreC()
                self.state = 537
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                if la_ == 1:
                    self.state = 535
                    self.match(GeoAnQuParser.T__10)
                    self.state = 536
                    self.coreC()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Aggregate(self):
            return self.getToken(GeoAnQuParser.Aggregate, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_aggre

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggre" ):
                listener.enterAggre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggre" ):
                listener.exitAggre(self)




    def aggre(self):

        localctx = GeoAnQuParser.AggreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_aggre)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 541
            self.match(GeoAnQuParser.Aggregate)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPO(self):
            return self.getToken(GeoAnQuParser.TOPO, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoR" ):
                listener.enterTopoR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoR" ):
                listener.exitTopoR(self)




    def topoR(self):

        localctx = GeoAnQuParser.TopoRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_topoR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(GeoAnQuParser.TOPO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRInContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoRIn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoRIn" ):
                listener.enterTopoRIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoRIn" ):
                listener.exitTopoRIn(self)




    def topoRIn(self):

        localctx = GeoAnQuParser.TopoRInContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_topoRIn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 545
            self.match(GeoAnQuParser.T__5)
            self.state = 552
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.T__64]:
                self.state = 546
                self.coreC()
                self.state = 549
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 547
                    self.match(GeoAnQuParser.T__10)
                    self.state = 548
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.state = 551
                self.densityNei()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Boolean(self):
            return self.getToken(GeoAnQuParser.Boolean, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_boolR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolR" ):
                listener.enterBoolR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolR" ):
                listener.exitBoolR(self)




    def boolR(self):

        localctx = GeoAnQuParser.BoolRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_boolR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.match(GeoAnQuParser.Boolean)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtremaRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Extrema(self):
            return self.getToken(GeoAnQuParser.Extrema, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extremaR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtremaR" ):
                listener.enterExtremaR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtremaR" ):
                listener.exitExtremaR(self)




    def extremaR(self):

        localctx = GeoAnQuParser.ExtremaRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_extremaR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 556
            self.match(GeoAnQuParser.Extrema)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistanceRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Distance(self):
            return self.getToken(GeoAnQuParser.Distance, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distanceR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistanceR" ):
                listener.enterDistanceR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistanceR" ):
                listener.exitDistanceR(self)




    def distanceR(self):

        localctx = GeoAnQuParser.DistanceRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_distanceR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 558
            self.match(GeoAnQuParser.Distance)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtreDistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExtreDist(self):
            return self.getToken(GeoAnQuParser.ExtreDist, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extreDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtreDist" ):
                listener.enterExtreDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtreDist" ):
                listener.exitExtreDist(self)




    def extreDist(self):

        localctx = GeoAnQuParser.ExtreDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_extreDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 560
            self.match(GeoAnQuParser.ExtreDist)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompareRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Compare(self):
            return self.getToken(GeoAnQuParser.Compare, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_compareR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompareR" ):
                listener.enterCompareR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompareR" ):
                listener.exitCompareR(self)




    def compareR(self):

        localctx = GeoAnQuParser.CompareRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_compareR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            self.match(GeoAnQuParser.Compare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity" ):
                listener.enterQuantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity" ):
                listener.exitQuantity(self)




    def quantity(self):

        localctx = GeoAnQuParser.QuantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_quantity)
        try:
            self.state = 568
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 564
                self.match(GeoAnQuParser.T__34)
                self.state = 565
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__35]:
                self.enterOuterAlt(localctx, 2)
                self.state = 566
                self.match(GeoAnQuParser.T__35)
                self.state = 567
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = GeoAnQuParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 570
            self.match(GeoAnQuParser.T__36)
            self.state = 571
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)




    def time(self):

        localctx = GeoAnQuParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.match(GeoAnQuParser.T__37)
            self.state = 574
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercent" ):
                listener.enterPercent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercent" ):
                listener.exitPercent(self)




    def percent(self):

        localctx = GeoAnQuParser.PercentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.match(GeoAnQuParser.T__35)
            self.state = 577
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DensityNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_densityNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDensityNei" ):
                listener.enterDensityNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDensityNei" ):
                listener.exitDensityNei(self)




    def densityNei(self):

        localctx = GeoAnQuParser.DensityNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_densityNei)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.quantity()
            self.state = 580
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__38 or _la==GeoAnQuParser.T__39):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBandNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBandNei" ):
                listener.enterDistBandNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBandNei" ):
                listener.exitDistBandNei(self)




    def distBandNei(self):

        localctx = GeoAnQuParser.DistBandNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_distBandNei)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 582
            self.match(GeoAnQuParser.T__40)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBand" ):
                listener.enterDistBand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBand" ):
                listener.exitDistBand(self)




    def distBand(self):

        localctx = GeoAnQuParser.DistBandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_distBand)
        try:
            self.state = 593
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.enterOuterAlt(localctx, 1)
                self.state = 584
                self.quantity()
                self.state = 585
                self.match(GeoAnQuParser.T__41)
                pass
            elif token in [GeoAnQuParser.T__41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 587
                self.match(GeoAnQuParser.T__41)
                self.state = 588
                self.quantity()
                self.state = 589
                self.match(GeoAnQuParser.T__16)
                self.state = 590
                self.quantity()
                self.state = 591
                self.match(GeoAnQuParser.T__42)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NetworkCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_networkC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNetworkC" ):
                listener.enterNetworkC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNetworkC" ):
                listener.exitNetworkC(self)




    def networkC(self):

        localctx = GeoAnQuParser.NetworkCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_networkC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 595
            self.match(GeoAnQuParser.T__43)
            self.state = 596
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NetworkQContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def ML(self):
            return self.getToken(GeoAnQuParser.ML, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_networkQ

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNetworkQ" ):
                listener.enterNetworkQ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNetworkQ" ):
                listener.exitNetworkQ(self)




    def networkQ(self):

        localctx = GeoAnQuParser.NetworkQContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_networkQ)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 598
            self.match(GeoAnQuParser.T__44)
            self.state = 599
            self.match(GeoAnQuParser.DIGIT)
            self.state = 600
            self.match(GeoAnQuParser.ML)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_objectC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectC" ):
                listener.enterObjectC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectC" ):
                listener.exitObjectC(self)




    def objectC(self):

        localctx = GeoAnQuParser.ObjectCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_objectC)
        try:
            self.state = 606
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__45]:
                self.enterOuterAlt(localctx, 1)
                self.state = 602
                self.match(GeoAnQuParser.T__45)
                self.state = 603
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 604
                self.match(GeoAnQuParser.T__46)
                self.state = 605
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_eventC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventC" ):
                listener.enterEventC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventC" ):
                listener.exitEventC(self)




    def eventC(self):

        localctx = GeoAnQuParser.EventCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_eventC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 608
            self.match(GeoAnQuParser.T__47)
            self.state = 609
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoreCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def ML(self):
            return self.getToken(GeoAnQuParser.ML, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_coreC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoreC" ):
                listener.enterCoreC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoreC" ):
                listener.exitCoreC(self)




    def coreC(self):

        localctx = GeoAnQuParser.CoreCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_coreC)
        try:
            self.state = 664
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 611
                self.match(GeoAnQuParser.T__48)
                self.state = 612
                self.match(GeoAnQuParser.DIGIT)
                self.state = 613
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__45]:
                self.enterOuterAlt(localctx, 2)
                self.state = 614
                self.match(GeoAnQuParser.T__45)
                self.state = 615
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__49]:
                self.enterOuterAlt(localctx, 3)
                self.state = 616
                self.match(GeoAnQuParser.T__49)
                self.state = 617
                self.match(GeoAnQuParser.DIGIT)
                self.state = 618
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__47]:
                self.enterOuterAlt(localctx, 4)
                self.state = 619
                self.match(GeoAnQuParser.T__47)
                self.state = 620
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__50]:
                self.enterOuterAlt(localctx, 5)
                self.state = 621
                self.match(GeoAnQuParser.T__50)
                self.state = 622
                self.match(GeoAnQuParser.DIGIT)
                self.state = 623
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__51]:
                self.enterOuterAlt(localctx, 6)
                self.state = 624
                self.match(GeoAnQuParser.T__51)
                self.state = 625
                self.match(GeoAnQuParser.DIGIT)
                self.state = 626
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__52]:
                self.enterOuterAlt(localctx, 7)
                self.state = 627
                self.match(GeoAnQuParser.T__52)
                self.state = 628
                self.match(GeoAnQuParser.DIGIT)
                self.state = 629
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__53]:
                self.enterOuterAlt(localctx, 8)
                self.state = 630
                self.match(GeoAnQuParser.T__53)
                self.state = 631
                self.match(GeoAnQuParser.DIGIT)
                self.state = 632
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__54]:
                self.enterOuterAlt(localctx, 9)
                self.state = 633
                self.match(GeoAnQuParser.T__54)
                self.state = 634
                self.match(GeoAnQuParser.DIGIT)
                self.state = 635
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__55]:
                self.enterOuterAlt(localctx, 10)
                self.state = 636
                self.match(GeoAnQuParser.T__55)
                self.state = 637
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__56]:
                self.enterOuterAlt(localctx, 11)
                self.state = 638
                self.match(GeoAnQuParser.T__56)
                self.state = 639
                self.match(GeoAnQuParser.DIGIT)
                self.state = 640
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__57]:
                self.enterOuterAlt(localctx, 12)
                self.state = 641
                self.match(GeoAnQuParser.T__57)
                self.state = 642
                self.match(GeoAnQuParser.DIGIT)
                self.state = 643
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__58]:
                self.enterOuterAlt(localctx, 13)
                self.state = 644
                self.match(GeoAnQuParser.T__58)
                self.state = 645
                self.match(GeoAnQuParser.DIGIT)
                self.state = 646
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__59]:
                self.enterOuterAlt(localctx, 14)
                self.state = 647
                self.match(GeoAnQuParser.T__59)
                self.state = 648
                self.match(GeoAnQuParser.DIGIT)
                self.state = 649
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__60]:
                self.enterOuterAlt(localctx, 15)
                self.state = 650
                self.match(GeoAnQuParser.T__60)
                self.state = 651
                self.match(GeoAnQuParser.DIGIT)
                self.state = 652
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__61]:
                self.enterOuterAlt(localctx, 16)
                self.state = 653
                self.match(GeoAnQuParser.T__61)
                self.state = 654
                self.match(GeoAnQuParser.DIGIT)
                self.state = 655
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__62]:
                self.enterOuterAlt(localctx, 17)
                self.state = 656
                self.match(GeoAnQuParser.T__62)
                self.state = 657
                self.match(GeoAnQuParser.DIGIT)
                self.state = 658
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__63]:
                self.enterOuterAlt(localctx, 18)
                self.state = 659
                self.match(GeoAnQuParser.T__63)
                self.state = 660
                self.match(GeoAnQuParser.DIGIT)
                self.state = 661
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__64]:
                self.enterOuterAlt(localctx, 19)
                self.state = 662
                self.match(GeoAnQuParser.T__64)
                self.state = 663
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def distBand(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistBandContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_support

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupport" ):
                listener.enterSupport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupport" ):
                listener.exitSupport(self)




    def support(self):

        localctx = GeoAnQuParser.SupportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_support)
        try:
            self.state = 673
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 666
                self.grid()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 667
                self.coreC()
                self.state = 670
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                if la_ == 1:
                    self.state = 668
                    self.match(GeoAnQuParser.T__10)
                    self.state = 669
                    self.coreC()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 672
                self.distBand()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtent" ):
                listener.enterExtent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtent" ):
                listener.exitExtent(self)




    def extent(self):

        localctx = GeoAnQuParser.ExtentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_extent)
        try:
            self.state = 678
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__46]:
                self.enterOuterAlt(localctx, 1)
                self.state = 675
                self.match(GeoAnQuParser.T__46)
                self.state = 676
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__65]:
                self.enterOuterAlt(localctx, 2)
                self.state = 677
                self.match(GeoAnQuParser.T__65)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemExContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_temEx

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemEx" ):
                listener.enterTemEx(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemEx" ):
                listener.exitTemEx(self)




    def temEx(self):

        localctx = GeoAnQuParser.TemExContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_temEx)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            self.match(GeoAnQuParser.T__36)
            self.state = 681
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





